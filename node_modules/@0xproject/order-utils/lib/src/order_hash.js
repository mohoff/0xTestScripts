"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var json_schemas_1 = require("@0xproject/json-schemas");
var types_1 = require("@0xproject/types");
var BN = require("bn.js");
var ethABI = require("ethereumjs-abi");
var ethUtil = require("ethereumjs-util");
var _ = require("lodash");
var assert_1 = require("./assert");
var INVALID_TAKER_FORMAT = 'instance.taker is not of a type(s) string';
/**
 * Converts BigNumber instance to BN
 * The only reason we convert to BN is to remain compatible with `ethABI.soliditySHA3` that
 * expects values of Solidity type `uint` to be passed as type `BN`.
 * We do not use BN anywhere else in the codebase.
 */
function bigNumberToBN(value) {
    return new BN(value.toString(), 10);
}
/**
 * Computes the orderHash for a supplied order.
 * @param   order   An object that conforms to the Order or SignedOrder interface definitions.
 * @return  The resulting orderHash from hashing the supplied order.
 */
function getOrderHashHex(order) {
    try {
        assert_1.assert.doesConformToSchema('order', order, json_schemas_1.schemas.orderSchema);
    }
    catch (error) {
        if (_.includes(error.message, INVALID_TAKER_FORMAT)) {
            var errMsg = 'Order taker must be of type string. If you want anyone to be able to fill an order - pass ZeroEx.NULL_ADDRESS';
            throw new Error(errMsg);
        }
        throw error;
    }
    var orderParts = [
        { value: order.exchangeContractAddress, type: types_1.SolidityTypes.Address },
        { value: order.maker, type: types_1.SolidityTypes.Address },
        { value: order.taker, type: types_1.SolidityTypes.Address },
        { value: order.makerTokenAddress, type: types_1.SolidityTypes.Address },
        { value: order.takerTokenAddress, type: types_1.SolidityTypes.Address },
        { value: order.feeRecipient, type: types_1.SolidityTypes.Address },
        {
            value: bigNumberToBN(order.makerTokenAmount),
            type: types_1.SolidityTypes.Uint256,
        },
        {
            value: bigNumberToBN(order.takerTokenAmount),
            type: types_1.SolidityTypes.Uint256,
        },
        {
            value: bigNumberToBN(order.makerFee),
            type: types_1.SolidityTypes.Uint256,
        },
        {
            value: bigNumberToBN(order.takerFee),
            type: types_1.SolidityTypes.Uint256,
        },
        {
            value: bigNumberToBN(order.expirationUnixTimestampSec),
            type: types_1.SolidityTypes.Uint256,
        },
        { value: bigNumberToBN(order.salt), type: types_1.SolidityTypes.Uint256 },
    ];
    var types = _.map(orderParts, function (o) { return o.type; });
    var values = _.map(orderParts, function (o) { return o.value; });
    var hashBuff = ethABI.soliditySHA3(types, values);
    var hashHex = ethUtil.bufferToHex(hashBuff);
    return hashHex;
}
exports.getOrderHashHex = getOrderHashHex;
/**
 * Checks if the supplied hex encoded order hash is valid.
 * Note: Valid means it has the expected format, not that an order with the orderHash exists.
 * Use this method when processing orderHashes submitted as user input.
 * @param   orderHash    Hex encoded orderHash.
 * @return  Whether the supplied orderHash has the expected format.
 */
function isValidOrderHash(orderHash) {
    // Since this method can be called to check if any arbitrary string conforms to an orderHash's
    // format, we only assert that we were indeed passed a string.
    assert_1.assert.isString('orderHash', orderHash);
    var schemaValidator = new json_schemas_1.SchemaValidator();
    var isValid = schemaValidator.validate(orderHash, json_schemas_1.schemas.orderHashSchema).valid;
    return isValid;
}
exports.isValidOrderHash = isValidOrderHash;
//# sourceMappingURL=order_hash.js.map