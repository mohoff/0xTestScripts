"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = require("@0xproject/assert");
var contract_wrappers_1 = require("@0xproject/contract-wrappers");
var order_utils_1 = require("@0xproject/order-utils");
var order_watcher_1 = require("@0xproject/order-watcher");
var web3_wrapper_1 = require("@0xproject/web3-wrapper");
var constants_1 = require("./utils/constants");
/**
 * The ZeroEx class is the single entry-point into the 0x.js library. It contains all of the library's functionality
 * and all calls to the library should be made through a ZeroEx instance.
 */
var ZeroEx = /** @class */ (function () {
    /**
     * Instantiates a new ZeroEx instance that provides the public interface to the 0x.js library.
     * @param   provider    The Provider instance you would like the 0x.js library to use for interacting with
     *                      the Ethereum network.
     * @param   config      The configuration object. Look up the type for the description.
     * @return  An instance of the 0x.js ZeroEx class.
     */
    function ZeroEx(provider, config) {
        assert_1.assert.isWeb3Provider('provider', provider);
        this._contractWrappers = new contract_wrappers_1.ContractWrappers(provider, config);
        this.proxy = this._contractWrappers.proxy;
        this.token = this._contractWrappers.token;
        this.exchange = this._contractWrappers.exchange;
        this.tokenRegistry = this._contractWrappers.tokenRegistry;
        this.etherToken = this._contractWrappers.etherToken;
    }
    /**
     * Generates a pseudo-random 256-bit salt.
     * The salt can be included in a 0x order, ensuring that the order generates a unique orderHash
     * and will not collide with other outstanding orders that are identical in all other parameters.
     * @return  A pseudo-random 256-bit number that can be used as a salt.
     */
    ZeroEx.generatePseudoRandomSalt = function () {
        return order_utils_1.generatePseudoRandomSalt();
    };
    /**
     * Verifies that the elliptic curve signature `signature` was generated
     * by signing `data` with the private key corresponding to the `signerAddress` address.
     * @param   data          The hex encoded data signed by the supplied signature.
     * @param   signature     An object containing the elliptic curve signature parameters.
     * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.
     * @return  Whether the signature is valid for the supplied signerAddress and data.
     */
    ZeroEx.isValidSignature = function (data, signature, signerAddress) {
        return order_utils_1.isValidSignature(data, signature, signerAddress);
    };
    /**
     * Computes the orderHash for a supplied order.
     * @param   order   An object that conforms to the Order or SignedOrder interface definitions.
     * @return  The resulting orderHash from hashing the supplied order.
     */
    ZeroEx.getOrderHashHex = function (order) {
        return order_utils_1.getOrderHashHex(order);
    };
    /**
     * Checks if the supplied hex encoded order hash is valid.
     * Note: Valid means it has the expected format, not that an order with the orderHash exists.
     * Use this method when processing orderHashes submitted as user input.
     * @param   orderHash    Hex encoded orderHash.
     * @return  Whether the supplied orderHash has the expected format.
     */
    ZeroEx.isValidOrderHash = function (orderHash) {
        return order_utils_1.isValidOrderHash(orderHash);
    };
    /**
     * A unit amount is defined as the amount of a token above the specified decimal places (integer part).
     * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent
     * to 1 unit.
     * @param   amount      The amount in baseUnits that you would like converted to units.
     * @param   decimals    The number of decimal places the unit amount has.
     * @return  The amount in units.
     */
    ZeroEx.toUnitAmount = function (amount, decimals) {
        assert_1.assert.isValidBaseUnitAmount('amount', amount);
        assert_1.assert.isNumber('decimals', decimals);
        var unitAmount = web3_wrapper_1.Web3Wrapper.toUnitAmount(amount, decimals);
        return unitAmount;
    };
    /**
     * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits
     * is the amount expressed in the smallest denomination.
     * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000
     * @param   amount      The amount of units that you would like converted to baseUnits.
     * @param   decimals    The number of decimal places the unit amount has.
     * @return  The amount in baseUnits.
     */
    ZeroEx.toBaseUnitAmount = function (amount, decimals) {
        assert_1.assert.isBigNumber('amount', amount);
        assert_1.assert.isNumber('decimals', decimals);
        var baseUnitAmount = web3_wrapper_1.Web3Wrapper.toBaseUnitAmount(amount, decimals);
        return baseUnitAmount;
    };
    /**
     * Sets a new web3 provider for 0x.js. Updating the provider will stop all
     * subscriptions so you will need to re-subscribe to all events relevant to your app after this call.
     * @param   provider    The Web3Provider you would like the 0x.js library to use from now on.
     * @param   networkId   The id of the network your provider is connected to
     */
    ZeroEx.prototype.setProvider = function (provider, networkId) {
        this._contractWrappers.setProvider(provider, networkId);
    };
    /**
     * Get the provider instance currently used by 0x.js
     * @return  Web3 provider instance
     */
    ZeroEx.prototype.getProvider = function () {
        return this._contractWrappers.getProvider();
    };
    /**
     * Get user Ethereum addresses available through the supplied web3 provider available for sending transactions.
     * @return  An array of available user Ethereum addresses.
     */
    ZeroEx.prototype.getAvailableAddressesAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var web3Wrapper, availableAddresses;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        web3Wrapper = this._contractWrappers._web3Wrapper;
                        return [4 /*yield*/, web3Wrapper.getAvailableAddressesAsync()];
                    case 1:
                        availableAddresses = _a.sent();
                        return [2 /*return*/, availableAddresses];
                }
            });
        });
    };
    /**
     * Signs an orderHash and returns it's elliptic curve signature.
     * This method currently supports TestRPC, Geth and Parity above and below V1.6.6
     * @param   orderHash       Hex encoded orderHash to sign.
     * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address
     *          must be available via the Provider supplied to 0x.js.
     * @param   shouldAddPersonalMessagePrefix  Some signers add the personal message prefix `\x19Ethereum Signed Message`
     *          themselves (e.g Parity Signer, Ledger, TestRPC) and others expect it to already be done by the client
     *          (e.g Metamask). Depending on which signer this request is going to, decide on whether to add the prefix
     *          before sending the request.
     * @return  An object containing the Elliptic curve signature parameters generated by signing the orderHash.
     */
    ZeroEx.prototype.signOrderHashAsync = function (orderHash, signerAddress, shouldAddPersonalMessagePrefix) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, order_utils_1.signOrderHashAsync(this._contractWrappers.getProvider(), orderHash, signerAddress, shouldAddPersonalMessagePrefix)];
            });
        });
    };
    /**
     * Waits for a transaction to be mined and returns the transaction receipt.
     * @param   txHash            Transaction hash
     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.
     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.
     * @return  Transaction receipt with decoded log args.
     */
    ZeroEx.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {
        if (pollingIntervalMs === void 0) { pollingIntervalMs = 1000; }
        return __awaiter(this, void 0, void 0, function () {
            var web3Wrapper, transactionReceiptWithDecodedLogs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        web3Wrapper = this._contractWrappers._web3Wrapper;
                        return [4 /*yield*/, web3Wrapper.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs)];
                    case 1:
                        transactionReceiptWithDecodedLogs = _a.sent();
                        return [2 /*return*/, transactionReceiptWithDecodedLogs];
                }
            });
        });
    };
    /**
     * Instantiates and returns a new OrderWatcher instance.
     * Defaults to watching the pending state.
     * @param   config      The configuration object. Look up the type for the description.
     * @return  An instance of the 0x.js OrderWatcher class.
     */
    ZeroEx.prototype.createOrderWatcherAsync = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            var web3Wrapper, networkId, provider, orderWatcher;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        web3Wrapper = this._contractWrappers._web3Wrapper;
                        return [4 /*yield*/, web3Wrapper.getNetworkIdAsync()];
                    case 1:
                        networkId = _a.sent();
                        provider = this._contractWrappers.getProvider();
                        orderWatcher = new order_watcher_1.OrderWatcher(provider, networkId, config);
                        return [2 /*return*/, orderWatcher];
                }
            });
        });
    };
    /**
     * When creating an order without a specified taker or feeRecipient you must supply the Solidity
     * address null type (as opposed to Javascripts `null`, `undefined` or empty string). We expose
     * this constant for your convenience.
     */
    ZeroEx.NULL_ADDRESS = constants_1.constants.NULL_ADDRESS;
    return ZeroEx;
}());
exports.ZeroEx = ZeroEx;
//# sourceMappingURL=0x.js.map